/*
 * Kruise
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1.21.1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
package cn.odboy.model.openkruise;

import com.google.gson.annotations.SerializedName;
import io.kubernetes.client.custom.IntOrString;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;

import javax.annotation.Generated;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

/**
 * UpdateStrategy indicates the UpdateStrategy that will be employed to update Pods in the CloneSet when a revision is made to Template.
 */
@ApiModel(description = "UpdateStrategy indicates the UpdateStrategy that will be employed to update Pods in the CloneSet when a revision is made to Template.")
@Generated(value = "io.swagger.codegen.languages.JavaClientCodegen", date = "2023-07-21T15:55:09.049+08:00")
public class KruiseAppsV1alpha1CloneSetUpdateStrategy {
    @SerializedName("inPlaceUpdateStrategy")
    private KruiseAppsPubInPlaceUpdateStrategy inPlaceUpdateStrategy = null;
    @SerializedName("maxSurge")
    private IntOrString maxSurge = null;
    @SerializedName("maxUnavailable")
    private IntOrString maxUnavailable = null;
    @SerializedName("partition")
    private IntOrString partition = null;
    @SerializedName("paused")
    private Boolean paused = null;
    @SerializedName("priorityStrategy")
    private KruiseAppsPubUpdatePriorityStrategy priorityStrategy = null;
    @SerializedName("scatterStrategy")
    private List<KruiseAppsV1alpha1UpdateScatterTerm> scatterStrategy = null;
    @SerializedName("type")
    private String type = null;

    public KruiseAppsV1alpha1CloneSetUpdateStrategy inPlaceUpdateStrategy(KruiseAppsPubInPlaceUpdateStrategy inPlaceUpdateStrategy) {
        this.inPlaceUpdateStrategy = inPlaceUpdateStrategy;
        return this;
    }

    /**
     * Get inPlaceUpdateStrategy
     *
     * @return inPlaceUpdateStrategy
     **/
    @ApiModelProperty(value = "")
    public KruiseAppsPubInPlaceUpdateStrategy getInPlaceUpdateStrategy() {
        return inPlaceUpdateStrategy;
    }

    public void setInPlaceUpdateStrategy(KruiseAppsPubInPlaceUpdateStrategy inPlaceUpdateStrategy) {
        this.inPlaceUpdateStrategy = inPlaceUpdateStrategy;
    }

    public KruiseAppsV1alpha1CloneSetUpdateStrategy maxSurge(IntOrString maxSurge) {
        this.maxSurge = maxSurge;
        return this;
    }

    /**
     * The maximum number of pods that can be scheduled above the desired replicas during update or specified delete. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding up. Defaults to 0.
     *
     * @return maxSurge
     **/
    @ApiModelProperty(value = "The maximum number of pods that can be scheduled above the desired replicas during update or specified delete. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding up. Defaults to 0.")
    public IntOrString getMaxSurge() {
        return maxSurge;
    }

    public void setMaxSurge(IntOrString maxSurge) {
        this.maxSurge = maxSurge;
    }

    public KruiseAppsV1alpha1CloneSetUpdateStrategy maxUnavailable(IntOrString maxUnavailable) {
        this.maxUnavailable = maxUnavailable;
        return this;
    }

    /**
     * The maximum number of pods that can be unavailable during update or scale. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding up by default. When maxSurge &gt; 0, absolute number is calculated from percentage by rounding down. Defaults to 20%.
     *
     * @return maxUnavailable
     **/
    @ApiModelProperty(value = "The maximum number of pods that can be unavailable during update or scale. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding up by default. When maxSurge > 0, absolute number is calculated from percentage by rounding down. Defaults to 20%.")
    public IntOrString getMaxUnavailable() {
        return maxUnavailable;
    }

    public void setMaxUnavailable(IntOrString maxUnavailable) {
        this.maxUnavailable = maxUnavailable;
    }

    public KruiseAppsV1alpha1CloneSetUpdateStrategy partition(IntOrString partition) {
        this.partition = partition;
        return this;
    }

    /**
     * Partition is the desired number of pods in old revisions. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding up by default. It means when partition is set during pods updating, (replicas - partition value) number of pods will be updated. Default value is 0.
     *
     * @return partition
     **/
    @ApiModelProperty(value = "Partition is the desired number of pods in old revisions. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding up by default. It means when partition is set during pods updating, (replicas - partition value) number of pods will be updated. Default value is 0.")
    public IntOrString getPartition() {
        return partition;
    }

    public void setPartition(IntOrString partition) {
        this.partition = partition;
    }

    public KruiseAppsV1alpha1CloneSetUpdateStrategy paused(Boolean paused) {
        this.paused = paused;
        return this;
    }

    /**
     * Paused indicates that the CloneSet is paused. Default value is false
     *
     * @return paused
     **/
    @ApiModelProperty(value = "Paused indicates that the CloneSet is paused. Default value is false")
    public Boolean isPaused() {
        return paused;
    }

    public void setPaused(Boolean paused) {
        this.paused = paused;
    }

    public KruiseAppsV1alpha1CloneSetUpdateStrategy priorityStrategy(KruiseAppsPubUpdatePriorityStrategy priorityStrategy) {
        this.priorityStrategy = priorityStrategy;
        return this;
    }

    /**
     * Get priorityStrategy
     *
     * @return priorityStrategy
     **/
    @ApiModelProperty(value = "")
    public KruiseAppsPubUpdatePriorityStrategy getPriorityStrategy() {
        return priorityStrategy;
    }

    public void setPriorityStrategy(KruiseAppsPubUpdatePriorityStrategy priorityStrategy) {
        this.priorityStrategy = priorityStrategy;
    }

    public KruiseAppsV1alpha1CloneSetUpdateStrategy scatterStrategy(List<KruiseAppsV1alpha1UpdateScatterTerm> scatterStrategy) {
        this.scatterStrategy = scatterStrategy;
        return this;
    }

    public KruiseAppsV1alpha1CloneSetUpdateStrategy addScatterStrategyItem(KruiseAppsV1alpha1UpdateScatterTerm scatterStrategyItem) {
        if (this.scatterStrategy == null) {
            this.scatterStrategy = new ArrayList<KruiseAppsV1alpha1UpdateScatterTerm>();
        }
        this.scatterStrategy.add(scatterStrategyItem);
        return this;
    }

    /**
     * ScatterStrategy defines the scatter rules to make pods been scattered when update. This will avoid pods with the same key-value to be updated in one batch. - Note that pods will be scattered after priority sort. So, although priority strategy and scatter strategy can be applied together, we suggest to use either one of them. - If scatterStrategy is used, we suggest to just use one term. Otherwise, the update order can be hard to understand.
     *
     * @return scatterStrategy
     **/
    @ApiModelProperty(value = "ScatterStrategy defines the scatter rules to make pods been scattered when update. This will avoid pods with the same key-value to be updated in one batch. - Note that pods will be scattered after priority sort. So, although priority strategy and scatter strategy can be applied together, we suggest to use either one of them. - If scatterStrategy is used, we suggest to just use one term. Otherwise, the update order can be hard to understand.")
    public List<KruiseAppsV1alpha1UpdateScatterTerm> getScatterStrategy() {
        return scatterStrategy;
    }

    public void setScatterStrategy(List<KruiseAppsV1alpha1UpdateScatterTerm> scatterStrategy) {
        this.scatterStrategy = scatterStrategy;
    }

    public KruiseAppsV1alpha1CloneSetUpdateStrategy type(String type) {
        this.type = type;
        return this;
    }

    /**
     * Type indicates the type of the CloneSetUpdateStrategy. Default is ReCreate.
     *
     * @return type
     **/
    @ApiModelProperty(value = "Type indicates the type of the CloneSetUpdateStrategy. Default is ReCreate.")
    public String getType() {
        return type;
    }

    public void setType(String type) {
        this.type = type;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (!(o instanceof KruiseAppsV1alpha1CloneSetUpdateStrategy)) {
            return false;
        }
        KruiseAppsV1alpha1CloneSetUpdateStrategy ioKruiseAppsV1alpha1CloneSetSpecUpdateStrategy = (KruiseAppsV1alpha1CloneSetUpdateStrategy) o;
        return Objects.equals(this.inPlaceUpdateStrategy, ioKruiseAppsV1alpha1CloneSetSpecUpdateStrategy.inPlaceUpdateStrategy) &&
                Objects.equals(this.maxSurge, ioKruiseAppsV1alpha1CloneSetSpecUpdateStrategy.maxSurge) &&
                Objects.equals(this.maxUnavailable, ioKruiseAppsV1alpha1CloneSetSpecUpdateStrategy.maxUnavailable) &&
                Objects.equals(this.partition, ioKruiseAppsV1alpha1CloneSetSpecUpdateStrategy.partition) &&
                Objects.equals(this.paused, ioKruiseAppsV1alpha1CloneSetSpecUpdateStrategy.paused) &&
                Objects.equals(this.priorityStrategy, ioKruiseAppsV1alpha1CloneSetSpecUpdateStrategy.priorityStrategy) &&
                Objects.equals(this.scatterStrategy, ioKruiseAppsV1alpha1CloneSetSpecUpdateStrategy.scatterStrategy) &&
                Objects.equals(this.type, ioKruiseAppsV1alpha1CloneSetSpecUpdateStrategy.type);
    }

    @Override
    public int hashCode() {
        return Objects.hash(inPlaceUpdateStrategy, maxSurge, maxUnavailable, partition, paused, priorityStrategy, scatterStrategy, type);
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("class KruiseAppsV1alpha1CloneSetSpecUpdateStrategy {\n");
        sb.append("    inPlaceUpdateStrategy: ").append(toIndentedString(inPlaceUpdateStrategy)).append("\n");
        sb.append("    maxSurge: ").append(toIndentedString(maxSurge)).append("\n");
        sb.append("    maxUnavailable: ").append(toIndentedString(maxUnavailable)).append("\n");
        sb.append("    partition: ").append(toIndentedString(partition)).append("\n");
        sb.append("    paused: ").append(toIndentedString(paused)).append("\n");
        sb.append("    priorityStrategy: ").append(toIndentedString(priorityStrategy)).append("\n");
        sb.append("    scatterStrategy: ").append(toIndentedString(scatterStrategy)).append("\n");
        sb.append("    type: ").append(toIndentedString(type)).append("\n");
        sb.append("}");
        return sb.toString();
    }

    /**
     * Convert the given object to string with each line indented by 4 spaces
     * (except the first line).
     */
    private String toIndentedString(Object o) {
        if (o == null) {
            return "null";
        }
        return o.toString().replace("\n", "\n    ");
    }
}
