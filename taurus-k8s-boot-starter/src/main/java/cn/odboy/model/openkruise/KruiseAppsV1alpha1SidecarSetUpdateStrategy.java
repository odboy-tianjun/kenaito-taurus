/*
 * Kruise
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1.21.1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
package cn.odboy.model.openkruise;

import com.google.gson.annotations.SerializedName;
import io.kubernetes.client.custom.IntOrString;
import io.kubernetes.client.openapi.models.V1LabelSelector;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;

import javax.annotation.Generated;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

/**
 * The sidecarset updateStrategy to use to replace existing pods with new ones.
 */
@ApiModel(description = "The sidecarset updateStrategy to use to replace existing pods with new ones.")
@Generated(value = "io.swagger.codegen.languages.JavaClientCodegen", date = "2023-07-21T15:55:09.049+08:00")
public class KruiseAppsV1alpha1SidecarSetUpdateStrategy {
    @SerializedName("maxUnavailable")
    private IntOrString maxUnavailable = null;
    @SerializedName("partition")
    private IntOrString partition = null;
    @SerializedName("paused")
    private Boolean paused = null;
    @SerializedName("priorityStrategy")
    private KruiseAppsPubUpdatePriorityStrategy priorityStrategy = null;
    @SerializedName("scatterStrategy")
    private List<KruiseAppsV1alpha1UpdateScatterTerm> scatterStrategy = null;
    @SerializedName("selector")
    private V1LabelSelector selector = null;
    @SerializedName("type")
    private String type = null;

    public KruiseAppsV1alpha1SidecarSetUpdateStrategy maxUnavailable(IntOrString maxUnavailable) {
        this.maxUnavailable = maxUnavailable;
        return this;
    }

    /**
     * The maximum number of SidecarSet pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of total number of SidecarSet pods at the start of the update (ex: 10%). Absolute number is calculated from percentage by rounding up. This cannot be 0. Default value is 1.
     *
     * @return maxUnavailable
     **/
    @ApiModelProperty(value = "The maximum number of SidecarSet pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of total number of SidecarSet pods at the start of the update (ex: 10%). Absolute number is calculated from percentage by rounding up. This cannot be 0. Default value is 1.")
    public IntOrString getMaxUnavailable() {
        return maxUnavailable;
    }

    public void setMaxUnavailable(IntOrString maxUnavailable) {
        this.maxUnavailable = maxUnavailable;
    }

    public KruiseAppsV1alpha1SidecarSetUpdateStrategy partition(IntOrString partition) {
        this.partition = partition;
        return this;
    }

    /**
     * Partition is the desired number of pods in old revisions. It means when partition is set during pods updating, (replicas - partition) number of pods will be updated. Default value is 0.
     *
     * @return partition
     **/
    @ApiModelProperty(value = "Partition is the desired number of pods in old revisions. It means when partition is set during pods updating, (replicas - partition) number of pods will be updated. Default value is 0.")
    public IntOrString getPartition() {
        return partition;
    }

    public void setPartition(IntOrString partition) {
        this.partition = partition;
    }

    public KruiseAppsV1alpha1SidecarSetUpdateStrategy paused(Boolean paused) {
        this.paused = paused;
        return this;
    }

    /**
     * Paused indicates that the SidecarSet is paused to update the injected pods, but it don&#39;t affect the webhook inject sidecar container into the newly created pods. default is false
     *
     * @return paused
     **/
    @ApiModelProperty(value = "Paused indicates that the SidecarSet is paused to update the injected pods, but it don't affect the webhook inject sidecar container into the newly created pods. default is false")
    public Boolean isPaused() {
        return paused;
    }

    public void setPaused(Boolean paused) {
        this.paused = paused;
    }

    public KruiseAppsV1alpha1SidecarSetUpdateStrategy priorityStrategy(KruiseAppsPubUpdatePriorityStrategy priorityStrategy) {
        this.priorityStrategy = priorityStrategy;
        return this;
    }

    /**
     * Get priorityStrategy
     *
     * @return priorityStrategy
     **/
    @ApiModelProperty(value = "")
    public KruiseAppsPubUpdatePriorityStrategy getPriorityStrategy() {
        return priorityStrategy;
    }

    public void setPriorityStrategy(KruiseAppsPubUpdatePriorityStrategy priorityStrategy) {
        this.priorityStrategy = priorityStrategy;
    }

    public KruiseAppsV1alpha1SidecarSetUpdateStrategy scatterStrategy(List<KruiseAppsV1alpha1UpdateScatterTerm> scatterStrategy) {
        this.scatterStrategy = scatterStrategy;
        return this;
    }

    public KruiseAppsV1alpha1SidecarSetUpdateStrategy addScatterStrategyItem(KruiseAppsV1alpha1UpdateScatterTerm scatterStrategyItem) {
        if (this.scatterStrategy == null) {
            this.scatterStrategy = new ArrayList<KruiseAppsV1alpha1UpdateScatterTerm>();
        }
        this.scatterStrategy.add(scatterStrategyItem);
        return this;
    }

    /**
     * ScatterStrategy defines the scatter rules to make pods been scattered when update. This will avoid pods with the same key-value to be updated in one batch. - Note that pods will be scattered after priority sort. So, although priority strategy and scatter strategy can be applied together, we suggest to use either one of them. - If scatterStrategy is used, we suggest to just use one term. Otherwise, the update order can be hard to understand.
     *
     * @return scatterStrategy
     **/
    @ApiModelProperty(value = "ScatterStrategy defines the scatter rules to make pods been scattered when update. This will avoid pods with the same key-value to be updated in one batch. - Note that pods will be scattered after priority sort. So, although priority strategy and scatter strategy can be applied together, we suggest to use either one of them. - If scatterStrategy is used, we suggest to just use one term. Otherwise, the update order can be hard to understand.")
    public List<KruiseAppsV1alpha1UpdateScatterTerm> getScatterStrategy() {
        return scatterStrategy;
    }

    public void setScatterStrategy(List<KruiseAppsV1alpha1UpdateScatterTerm> scatterStrategy) {
        this.scatterStrategy = scatterStrategy;
    }

    public KruiseAppsV1alpha1SidecarSetUpdateStrategy selector(V1LabelSelector selector) {
        this.selector = selector;
        return this;
    }

    /**
     * Get selector
     *
     * @return selector
     **/
    @ApiModelProperty(value = "")
    public V1LabelSelector getSelector() {
        return selector;
    }

    public void setSelector(V1LabelSelector selector) {
        this.selector = selector;
    }

    public KruiseAppsV1alpha1SidecarSetUpdateStrategy type(String type) {
        this.type = type;
        return this;
    }

    /**
     * Type is NotUpdate, the SidecarSet don&#39;t update the injected pods, it will only inject sidecar container into the newly created pods. Type is RollingUpdate, the SidecarSet will update the injected pods to the latest version on RollingUpdate Strategy. default is RollingUpdate
     *
     * @return type
     **/
    @ApiModelProperty(value = "Type is NotUpdate, the SidecarSet don't update the injected pods, it will only inject sidecar container into the newly created pods. Type is RollingUpdate, the SidecarSet will update the injected pods to the latest version on RollingUpdate Strategy. default is RollingUpdate")
    public String getType() {
        return type;
    }

    public void setType(String type) {
        this.type = type;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (!(o instanceof KruiseAppsV1alpha1SidecarSetUpdateStrategy)) {
            return false;
        }
        KruiseAppsV1alpha1SidecarSetUpdateStrategy ioKruiseAppsV1alpha1SidecarSetSpecUpdateStrategy = (KruiseAppsV1alpha1SidecarSetUpdateStrategy) o;
        return Objects.equals(this.maxUnavailable, ioKruiseAppsV1alpha1SidecarSetSpecUpdateStrategy.maxUnavailable) &&
                Objects.equals(this.partition, ioKruiseAppsV1alpha1SidecarSetSpecUpdateStrategy.partition) &&
                Objects.equals(this.paused, ioKruiseAppsV1alpha1SidecarSetSpecUpdateStrategy.paused) &&
                Objects.equals(this.priorityStrategy, ioKruiseAppsV1alpha1SidecarSetSpecUpdateStrategy.priorityStrategy) &&
                Objects.equals(this.scatterStrategy, ioKruiseAppsV1alpha1SidecarSetSpecUpdateStrategy.scatterStrategy) &&
                Objects.equals(this.selector, ioKruiseAppsV1alpha1SidecarSetSpecUpdateStrategy.selector) &&
                Objects.equals(this.type, ioKruiseAppsV1alpha1SidecarSetSpecUpdateStrategy.type);
    }

    @Override
    public int hashCode() {
        return Objects.hash(maxUnavailable, partition, paused, priorityStrategy, scatterStrategy, selector, type);
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("class KruiseAppsV1alpha1SidecarSetSpecUpdateStrategy {\n");
        sb.append("    maxUnavailable: ").append(toIndentedString(maxUnavailable)).append("\n");
        sb.append("    partition: ").append(toIndentedString(partition)).append("\n");
        sb.append("    paused: ").append(toIndentedString(paused)).append("\n");
        sb.append("    priorityStrategy: ").append(toIndentedString(priorityStrategy)).append("\n");
        sb.append("    scatterStrategy: ").append(toIndentedString(scatterStrategy)).append("\n");
        sb.append("    selector: ").append(toIndentedString(selector)).append("\n");
        sb.append("    type: ").append(toIndentedString(type)).append("\n");
        sb.append("}");
        return sb.toString();
    }

    /**
     * Convert the given object to string with each line indented by 4 spaces
     * (except the first line).
     */
    private String toIndentedString(Object o) {
        if (o == null) {
            return "null";
        }
        return o.toString().replace("\n", "\n    ");
    }
}
